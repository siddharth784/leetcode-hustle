class Solution {
    public int findMin(int[] nums) {
//QUES. SAYS TO BE DONE IN O(log N). THERE MOST DEFINITELY IS BINARY SEARCH. BUT HOW WOULD WE GET TO KNOW WHICH SIDE, LEFT OR RIGHT TO MOVE AT EACH STEP??? I FIGURE THAT OUT ON PAPER: 
// 2 CASES. 
// CALL MIN ELEMENT THE 'PIVOT' SINCE AFTER ARRAY ROTATION,IT WILL ACT AS PIVOT B/W RIGHT PARTITION AND LEFT PARTITION OF ORIGINAL SORTED ARRAY       
//IF(NUMS[LO]<=NUMS[HI] IT MEANS THE ARRAY IS SORTED SO THE PIVOT WILL OBV. LIE TO THE LEFT SIDE.HENCE HI=MID-1. NOTE: WHAT WE DON'T HAVE TO DO HERE IS RETURN NUMS[LO] RIGHT AWAY INSTEAD OF REGISTER NUMS[MID]->MOVING TO THE LEFT SUBARRAY. THIS IS CUZ IT WILL GIVE WRONG ANSWER IN CASES LIKE [3,1,2] WHERE WHEN LO=HI=3 IT WILL RETURN 3 INSTEAD OF 1. RUN IF YOU WANT TO UNDERSTAND)  
        
//ELSE CASE MEIN WE DON'T HAVE ANY IDEA KI PIVOT WILL OCCUR LEFT OR RIGHT CUZ IT LIES SOMEWHERE IN THE MIDDLE. WARNA NUMS[LO] NUMS[HI] SE BADA NHI HOTA. SO MIDDLE MEIN HAI BUT WHERE? WELL,IF NUMS[LO]<=NUMS[MID],THEN IT MEANS THAT THE LEFT SUBARRAY IS SORTED WHICH MEANS THAT PIVOT KAHIN RIGHT SUBARRAY MEIN HOGA,KYUKI PURA SUBARRAY TO INCREASING HAI NHI, TO FIR LEFT SUBARRAY INCREASING HONE KA MTLB H KI THE MENACE(THE PIVOT) IS ON THE RIGHT SIDE. THUS,LO=MID+1. AND IF NUMS[LO]>NUMS[MID], THEN THE PIVOT LIES IN THE LEFT SUBARRAY.
        
        int lo=0,hi=nums.length-1;
        int min=Integer.MAX_VALUE;
        while(lo<=hi){
            // System.out.println("lo = "+lo+",hi = "+hi);
            int mid=(lo+hi)/2;
            
            min=Math.min(min,nums[mid]);
            if(nums[lo]<=nums[hi])
                // return nums[lo];
                hi=mid-1;
            else{
                if(nums[lo]>nums[mid])
                    hi=mid-1;
                else
                    lo=mid+1;
            }
            
        }
        return min;
    }
}