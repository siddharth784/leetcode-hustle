class Solution {
    public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) {
        //ATTEMPT2: BINARY SEARCH APPROACH O(N*LOGN). TBH THIS APPROACH ISN'T HARD TO REACH AT. JUST FURTHER DEDUCE THE EQUATION WHICH IS INSIDE IF CONDITION IN ATTEMPT1. AND YOU'LL REACH AT aliceBox needs to be equal to bobBox+(aliceCandies-bobCandies)/2.
        int aliceTotal=0,bobTotal=0;
        for(int candies:aliceSizes)
            aliceTotal+=candies;
        for(int candies:bobSizes)
            bobTotal+=candies;
        int k=(aliceTotal-bobTotal)/2,n=aliceSizes.length;
        
        Arrays.sort(aliceSizes);
        for(int bobBox:bobSizes){
            int atarget=k+bobBox; //as in, the no. of candies that alice's box must have, which when exchanged with bob's current box, will balance both's total.
            int lo=0,hi=n-1;
            while(lo<=hi){
                int mid=(lo+hi)/2;
                if(aliceSizes[mid]==atarget)
                    return new int[]{atarget,bobBox};
                
                if(aliceSizes[mid]<atarget)
                    lo=mid+1;
                else
                    hi=mid-1;
            }
            
        }
        return  new int[]{0,0};
    }
}
        
//         //ATTEMPT1:BRUTE FORCE O(n2). SUCCESS.
//         int aliceCandies=0,bobCandies=0;
//         for(int candies:aliceSizes)
//             aliceCandies+=candies;
//         for(int candies:bobSizes)
//             bobCandies+=candies;
        
//         for(int i=0;i<aliceSizes.length;i++){
//             for(int j=0;j<bobSizes.length;j++){
//                 if(aliceCandies-aliceSizes[i]+bobSizes[j]==bobCandies-bobSizes[j]+aliceSizes[i]){
//                     return new int[]{aliceSizes[i],bobSizes[j]};
//                 }
//             }
//         }
//         return new int[]{-1,-1};
//     }
// }